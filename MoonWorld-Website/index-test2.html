<!DOCTYPE html>
<html lang="ko">
<!--  MoonWorld Project index.html  -->
<!--  https://infinite-jasonm.github.io/MoonWorld/MoonWorld-Website/Index.html  -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>가상의 달 세계</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-slate-900 text-slate-100;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen w-screen overflow-hidden">

    <!-- 3D 캔버스 -->
    <canvas id="moon-canvas" class="w-full h-full"></canvas>

    <!-- UI 오버레이 -->
    <div class="absolute top-0 left-0 right-0 flex flex-col items-center p-4 pointer-events-none">
        <h1 class="text-3xl sm:text-4xl font-bold mb-2 text-center text-slate-50">가상의 우주</h1>
        <p class="text-lg text-center text-slate-300">
            마우스를 드래그하여 시점을 변경하세요.
        </p>
    </div>

    <!-- 블록 정보 팝업 (초기에는 숨김) -->
    <div id="block-info-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 transition-opacity duration-300">
        <div class="bg-slate-800 rounded-xl shadow-lg p-6 sm:p-8 w-full max-w-sm sm:max-w-md pointer-events-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 id="modal-title" class="text-2xl font-bold text-emerald-400">블록 정보</h2>
                <button id="close-modal" class="p-1 rounded-full text-slate-400 hover:bg-slate-700 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="space-y-4">
                <p id="block-id-display" class="text-slate-300 text-sm">블록 ID: #000</p>
                <div>
                    <span class="font-semibold text-slate-400">면적:</span> <span id="block-area" class="text-slate-200">N/A</span>
                </div>
                <div>
                    <span class="font-semibold text-slate-400">지질 상태:</span> <span id="block-geology" class="text-slate-200">N/A</span>
                </div>
                <div>
                    <span class="font-semibold text-slate-400">발전 상태:</span> <span id="block-status" class="text-slate-200">N/A</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 3D Scene Setup ---
            const canvas = document.getElementById('moon-canvas');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000); 
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // --- Lighting Setup ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.9);
            mainLight.position.set(5, 5, 5).normalize();
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.2);
            fillLight.position.set(-5, -5, -5).normalize();
            scene.add(fillLight);

            // --- Creating a basic starry background ---
            const starCount = 1000;
            const starGeometry = new THREE.SphereGeometry(0.7, 32, 32); 
            const starMaterial = new THREE.MeshBasicMaterial();
            const stars = new THREE.Group();

            for (let i = 0; i < starCount; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial.clone());
                star.position.x = (Math.random() - 0.5) * 2000;
                star.position.y = (Math.random() - 0.5) * 2000;
                star.position.z = (Math.random() - 0.5) * 2000;

                const r = Math.random() * 0.5 + 0.5;
                const g = Math.random() * 0.5 + 0.5;
                const b = Math.random() * 0.5 + 0.5;
                star.material.color.setRGB(r, g, b);

                star.userData.twinkleSpeed = Math.random() * 100 + 0.1;
                star.userData.twinkleOffset = Math.random() * Math.PI * 2;
                star.material.opacity = Math.random() * 0.5 + 0.5;
                stars.add(star);
            }
            scene.add(stars);

            // --- Galaxy Creation (Main Group) ---
            const galaxyGroup = new THREE.Group();
            scene.add(galaxyGroup);
            galaxyGroup.position.set(0, 0, -1500); // 은하계 위치를 뒤로 이동
            galaxyGroup.rotation.x = Math.PI / 8; // X축으로 약간 기울이기
            
            const galaxySize = 200;
            const diskThickness = 20;
            const coreRadius = 50;

            const armSettings = [
                { arms: 8, stars: 3000, size: 1.0, thickness: 1.0, tightness: 1.0, direction: -1, hueRange: [0.95, 0.5] },
                { arms: 8, stars: 3000, size: 1.5, thickness: 0.8, tightness: 0.8, direction: -1, hueRange: [0.95, 0.5] },
                { arms: 4, stars: 4000, size: 1.8, thickness: 1.2, tightness: 0.8, direction: -1, hueRange: [0.95, 0.5] },
                { arms: 5, stars: 3000, size: 1.6, thickness: 0.5, tightness: 0.5, direction: -1, hueRange: [0.95, 0.5] },
                { arms: 7, stars: 3000, size: 1.9, thickness: 0.9, tightness: 0.7, direction: -1, hueRange: [0.95, 0.5] },
                { arms: 6, stars: 2500, size: 2.1, thickness: 1.5, tightness: 0.4, direction: -1, hueRange: [0.7, 0.1] },
                { arms: 12, stars: 2000, size: 2.3, thickness: 0.7, tightness: 0.3, direction: -1, hueRange: [0.5, 0.2] }
            ];

            armSettings.forEach(settings => {
                const totalGalaxyStars = settings.arms * settings.stars;
                const galaxyStarsGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(totalGalaxyStars * 3);
                const colors = new Float32Array(totalGalaxyStars * 3);
                const color = new THREE.Color();

                for (let armIndex = 0; armIndex < settings.arms; armIndex++) {
                    const armOffsetAngle = (Math.PI * 2 / settings.arms) * armIndex;
                    for (let i = 0; i < settings.stars; i++) {
                        const distance = (i / settings.stars) * (galaxySize * settings.size);
                        
                        const densityThreshold = 0.7;
                        const thinningFactor = Math.max(0, (distance / (galaxySize * settings.size) - densityThreshold) / (1 - densityThreshold));
                        if (Math.random() < thinningFactor) {
                            continue;
                        }

                        const angle = settings.direction * settings.tightness * Math.log(distance > 0 ? distance : 0.001) + (Math.random() - 0.5) * 0.2 + armOffsetAngle;

                        const x = distance * Math.cos(angle);
                        const y = (Math.random() - 0.5) * (diskThickness * settings.thickness) * (1 - distance / (galaxySize * settings.size));
                        const z = distance * Math.sin(angle);

                        const distanceXY = Math.sqrt(x*x + z*z);
                        if (distanceXY < coreRadius) {
                            continue; 
                        }

                        const starIndex = armIndex * settings.stars + i;
                        positions[starIndex * 3] = x;
                        positions[starIndex * 3 + 1] = y;
                        positions[starIndex * 3 + 2] = z;

                        const hue = settings.hueRange[0] + (distance / (galaxySize * settings.size)) * (settings.hueRange[1] - settings.hueRange[0]);
                        const saturation = 0.8 + Math.random() * 0.2;
                        const lightness = 0.7 + Math.random() * 0.2;
                        color.setHSL(hue % 1, saturation, lightness);
                        
                        colors[starIndex * 3] = color.r;
                        colors[starIndex * 3 + 1] = color.g;
                        colors[starIndex * 3 + 2] = color.b;
                    }
                }

                galaxyStarsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                galaxyStarsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const galaxyMaterial = new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent: true, opacity: 0.9, sizeAttenuation: true });
                galaxyGroup.add(new THREE.Points(galaxyStarsGeometry, galaxyMaterial));
            });
            
            // --- 불규칙하게 흩어진 별들 추가 ---
            const scatteredStarCount = 10000;
            const scatteredStarsGeometry = new THREE.BufferGeometry();
            const scatteredPositions = new Float32Array(scatteredStarCount * 3);
            const scatteredColors = new Float32Array(scatteredStarCount * 3);
            const scatteredStarColor = new THREE.Color();

            for (let i = 0; i < scatteredStarCount; i++) {
                let x, y, z;
                let distanceXY;
                const maxDistance = galaxySize * 3; // 불규칙 별들의 범위를 나선팔보다 넓게 조정합니다.

                do {
                    const radius = Math.sqrt(Math.random()) * maxDistance;
                    const angle = Math.random() * Math.PI * 2;
                    x = radius * Math.cos(angle);
                    z = radius * Math.sin(angle);
                    y = (Math.random() - 0.5) * diskThickness;
                    distanceXY = Math.sqrt(x * x + z * z);
                } while (distanceXY < coreRadius);
                
                scatteredPositions[i * 3] = x;
                scatteredPositions[i * 3 + 1] = y;
                scatteredPositions[i * 3 + 2] = z;
                
                const lightness = 0.8 + Math.random() * 0.2;
                scatteredStarColor.setHSL(0, 0, lightness);
                
                scatteredColors[i * 3] = scatteredStarColor.r;
                scatteredColors[i * 3 + 1] = scatteredStarColor.g;
                scatteredColors[i * 3 + 2] = scatteredStarColor.b;
            }

            scatteredStarsGeometry.setAttribute('position', new THREE.BufferAttribute(scatteredPositions, 3));
            scatteredStarsGeometry.setAttribute('color', new THREE.BufferAttribute(scatteredColors, 3));
            const scatteredStarsMaterial = new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent: true, opacity: 0.8, sizeAttenuation: true });
            const scatteredStars = new THREE.Points(scatteredStarsGeometry, scatteredStarsMaterial);
            galaxyGroup.add(scatteredStars);

            // --- 은하 중심축 내부의 불규칙 별들 (100개) ---
            const innerStarCount = 100;
            const innerStarsGeometry = new THREE.BufferGeometry();
            const innerPositions = new Float32Array(innerStarCount * 3);
            const innerColors = new Float32Array(innerStarCount * 3);
            const coreHeight = galaxySize * 0.6; 
            const innerColor = new THREE.Color();

            for (let i = 0; i < innerStarCount; i++) {
                const radius = Math.random() * coreRadius;
                const angle = Math.random() * Math.PI * 2;
                
                innerPositions[i * 3] = radius * Math.cos(angle);
                innerPositions[i * 3 + 1] = (Math.random() - 0.5) * coreHeight;
                innerPositions[i * 3 + 2] = radius * Math.sin(angle);
                
                const lightness = 0.8 + Math.random() * 0.2;
                innerColor.setHSL(0, 0, lightness);
                
                innerColors[i * 3] = innerColor.r;
                innerColors[i * 3 + 1] = innerColor.g;
                innerColors[i * 3 + 2] = innerColor.b;
            }
            
            innerStarsGeometry.setAttribute('position', new THREE.BufferAttribute(innerPositions, 3));
            innerStarsGeometry.setAttribute('color', new THREE.BufferAttribute(innerColors, 3));
            const innerStarsMaterial = new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent: true, opacity: 1.0, sizeAttenuation: true });
            const innerCoreStars = new THREE.Points(innerStarsGeometry, innerStarsMaterial);
            galaxyGroup.add(innerCoreStars);

            // --- Moon and objects group ---
            const moonGroup = new THREE.Group();
            scene.add(moonGroup);

            const moonRadius = 5;
            const moonGeometry = new THREE.SphereGeometry(moonRadius, 64, 64);
            const textureLoader = new THREE.TextureLoader();
            const moonTextureUrl = 'https://infinite-jasonm.github.io/MoonWorld/MoonWorld-Website/assets/textures/lroc_color_poles_2k.png';
            const moonTexture = textureLoader.load(moonTextureUrl);

            const moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moonGroup.add(moon);

            // --- 달 표면 위에 오브젝트 생성 ---
            const moonObjects = new THREE.Group();
            moonGroup.add(moonObjects);

            function createLander() {
                const landerGroup = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0xc0c0c0 }));
                landerGroup.add(body);
                const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
                const legMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                const leg1 = new THREE.Mesh(legGeometry, legMaterial);
                leg1.position.set(-0.2, -0.4, -0.2);
                landerGroup.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, legMaterial);
                leg2.position.set(0.2, -0.4, -0.2);
                landerGroup.add(leg2);
                const leg3 = new THREE.Mesh(legGeometry, legMaterial);
                leg3.position.set(-0.2, -0.4, 0.2);
                landerGroup.add(leg3);
                const leg4 = new THREE.Mesh(legGeometry, legMaterial);
                leg4.position.set(0.2, -0.4, 0.2);
                landerGroup.add(leg4);
                landerGroup.name = "lander";
                return landerGroup;
            }

            function createBase() {
                const baseGroup = new THREE.Group();
                const dome = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5), new THREE.MeshStandardMaterial({ color: 0x1a75ff, transparent: true, opacity: 0.8 }));
                dome.position.y = 0.5;
                baseGroup.add(dome);
                const module = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x808080 }));
                baseGroup.add(module);
                baseGroup.name = "base";
                return baseGroup;
            }

            function getMoonSurfacePosition(latitude, longitude) {
                const phi = (90 - latitude) * Math.PI / 180;
                const theta = (longitude + 180) * Math.PI / 180;
                const x = -moonRadius * Math.sin(phi) * Math.cos(theta);
                const y = moonRadius * Math.cos(phi);
                const z = moonRadius * Math.sin(phi) * Math.sin(theta);
                return new THREE.Vector3(x, y, z);
            }

            const lander = createLander();
            const landerPosition = getMoonSurfacePosition(20, -100);
            lander.position.copy(landerPosition);
            lander.lookAt(new THREE.Vector3(0, 0, 0));
            moonObjects.add(lander);

            const base = createBase();
            const basePosition = getMoonSurfacePosition(-30, 150);
            base.position.copy(basePosition);
            base.lookAt(new THREE.Vector3(0, 0, 0));
            moonObjects.add(base);

            const pointsOfInterest = [
                { name: "고요의 바다", lat: 0.8, lon: 23.5, description: "아폴로 11호가 처음 착륙한 장소로, 인류의 첫 발자국이 남겨진 곳입니다.", type: 'mare' },
                { name: "티코 분화구", lat: -43.3, lon: -11.2, description: "달에서 가장 밝은 분화구 중 하나로, 거대한 방사형 줄무늬가 특징입니다.", type: 'crater' },
                { name: "코페르니쿠스 분화구", lat: 9.7, lon: -20.1, description: "달의 가장 유명한 분화구 중 하나입니다. 그 웅장한 지형으로 '달의 왕자'라고 불립니다.", type: 'crater' }
            ];

            const poiGroup = new THREE.Group();
            moonGroup.add(poiGroup);

            pointsOfInterest.forEach(poi => {
                const poiGeometry = new THREE.IcosahedronGeometry(0.2, 1);
                const poiMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500, emissiveIntensity: 0.5 });
                const poiMesh = new THREE.Mesh(poiGeometry, poiMaterial);
                const position = getMoonSurfacePosition(poi.lat, poi.lon);
                poiMesh.position.copy(position);
                poiMesh.lookAt(new THREE.Vector3(0, 0, 0));
                poiMesh.userData = poi;
                poiGroup.add(poiMesh);
            });

            const blockData = {};
            const segmentsX = 60;
            const segmentsY = 30;
            
            for (let x = 0; x < segmentsX; x++) {
                for (let y = 0; y < segmentsY; y++) {
                    const blockId = `block-${x}-${y}`;
                    blockData[blockId] = {
                        area: `${(Math.random() * 100 + 1).toFixed(2)} km²`,
                        geology: ['화산암', '퇴적암', '현무암'][Math.floor(Math.random() * 3)],
                        status: ['미개발', '개발 중', '개발 완료'][Math.floor(Math.random() * 3)]
                    };
                }
            }

            const blockVisualizations = new THREE.Group();
            moonGroup.add(blockVisualizations);
            const gridGeometry = new THREE.SphereGeometry(moonRadius * 1.001, segmentsX, segmentsY); 
            const edges = new THREE.EdgesGeometry(gridGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x64748b, transparent: true, opacity: 0.2 });
            const gridLines = new THREE.LineSegments(edges, lineMaterial);
            blockVisualizations.add(gridLines);

            const interactiveObjects = [moon, lander, base, ...poiGroup.children];

            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(interactiveObjects, true);
                if (intersects.length > 0) {
                    if (!isHoveringObject) {
                        isHoveringObject = true;
                        document.body.style.cursor = 'pointer';
                        const object = intersects[0].object.parent.name || intersects[0].object.name;
                        if(object === 'moon'){
                            moon.material.emissiveIntensity = 0.2;
                        }
                    }
                } else {
                    if (isHoveringObject) {
                        isHoveringObject = false;
                        document.body.style.cursor = 'default';
                        moon.material.emissiveIntensity = 0;
                    }
                }
            }
            
            function onMouseClick(event) {
                if (document.getElementById('block-info-modal').contains(event.target)) {
                    return;
                }
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(interactiveObjects, true);
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const object = hit.object.parent ? hit.object.parent.name : hit.object.name || hit.object.userData.name;
                    const hitUserData = hit.object.userData;

                    let title, idDisplay, area, geology, status;
                    if (object === 'lander') {
                        title = '착륙선 정보';
                        idDisplay = '이곳은 아폴로 11호 착륙 지점입니다.';
                        area = 'N/A';
                        geology = 'N/A';
                        status = '임무 완료';
                    } else if (object === 'base') {
                        title = '기지 정보';
                        idDisplay = '기지 A-1';
                        area = '2.5 km²';
                        geology = '현무암';
                        status = '운영 중';
                    } else if (hitUserData.type) { 
                        const poi = hitUserData;
                        title = poi.name;
                        idDisplay = poi.description;
                        area = `위도: ${poi.lat.toFixed(2)}°, 경도: ${poi.lon.toFixed(2)}°`;
                        geology = 'N/A';
                        status = '명소';
                    } else if (object === 'moon') {
                        const hitPoint = hit.point;
                        const lat = (Math.acos(hitPoint.y / moonRadius) * 180 / Math.PI) - 90;
                        const lon = (Math.atan2(hitPoint.z, hitPoint.x) * 180 / Math.PI);
                        
                        const blockX = Math.floor((lon + 180) / (360 / segmentsX));
                        const blockY = Math.floor((lat + 90) / (180 / segmentsY));
                        const blockId = `block-${blockX}-${blockY}`;
                        const data = blockData[blockId] || { area: 'N/A', geology: 'N/A', status: 'N/A' };
                        
                        title = `블록 정보: ${blockId}`;
                        idDisplay = `블록 ID: ${blockId}`;
                        area = data.area;
                        geology = data.geology;
                        status = data.status;
                    }
                    document.getElementById('modal-title').textContent = title;
                    document.getElementById('block-id-display').textContent = idDisplay;
                    document.getElementById('block-area').textContent = area;
                    document.getElementById('block-geology').textContent = geology;
                    document.getElementById('block-status').textContent = status;
                    document.getElementById('block-info-modal').classList.remove('hidden');
                }
            }
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onMouseClick, false);
            
            const blockInfoModal = document.getElementById('block-info-modal');
            const closeModalButton = document.getElementById('close-modal');

            closeModalButton.addEventListener('click', () => { blockInfoModal.classList.add('hidden'); });
            blockInfoModal.addEventListener('click', (event) => {
                if (event.target === blockInfoModal) { blockInfoModal.classList.add('hidden'); }
            });

            // --- Window Resize Handler ---
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // --- Optimized Meteor System ---
            const meteorCount = 10;
            const meteorGroup = new THREE.Group();
            scene.add(meteorGroup);

            const meteorData = [];
            const particleCount = 200;
            const particleTrailGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            const particleOpacities = new Float32Array(particleCount);

            const particleMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(particleTrailGeometry, particleMaterial);
            meteorGroup.add(particles);

            function createMeteor() {
                const startPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 5000,
                    (Math.random() - 0.5) * 5000,
                    (Math.random() - 0.5) * 5000
                );
                const endPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 5000,
                    (Math.random() - 0.5) * 5000,
                    (Math.random() - 0.5) * 5000
                );
                const direction = endPos.clone().sub(startPos).normalize();
                const speed = 5 + Math.random() * 10;
                
                const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                meteorData.push({
                    position: startPos,
                    velocity: direction.multiplyScalar(speed),
                    color: baseColor,
                    isAlive: true
                });
            }

            for(let i = 0; i < meteorCount; i++) {
                createMeteor();
            }
            
            // --- Camera Position Setup ---
            camera.position.set(0, 0, 150); // 달에 포커스를 맞추고 뒤로 물러납니다.
            
            // --- Mouse Controls (OrbitControls) ---
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                
                // Star twinkling effect
                const time = Date.now() * 0.00005;
                stars.children.forEach(star => {
                    const brightness = Math.sin(star.userData.twinkleSpeed * time + star.userData.twinkleOffset) * 0.5 + 0.5;
                    star.material.opacity = brightness;
                });
                
                // Galaxy & Moon Rotation
                galaxyGroup.rotation.y -= 0.0005;
                moonGroup.rotation.y += 0.0005;

                // Meteor Trail Update (Optimized)
                const particlesPerMeteor = Math.floor(particleCount / meteorCount);
                for (let i = 0; i < meteorData.length; i++) {
                    const meteor = meteorData[i];
                    if (!meteor.isAlive) continue;

                    meteor.position.add(meteor.velocity);

                    // Re-create a meteor if it flies out of view
                    if (meteor.position.length() > 5000) {
                        meteor.isAlive = false;
                        createMeteor();
                    }
                }
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            // Start the animation after all setup
            animate();
        });
    </script>
</body>
</html>
